var documenterSearchIndex = {"docs":
[{"location":"test_contents/#Description-of-Contents","page":"Description of Contents","title":"Description of Contents","text":"","category":"section"},{"location":"backward_inversion/#Inversioin-using-Automatic-Differentiation","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"In this section, we describe three inversion problems in seismic imaging: inverting velocity, inverting source location and time function, and inverting rupture process. ","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Despite the method described here is also applicable to elastic wave equation, we consider the simpler the acoustic wave equation beginaligned u_tt - c^2Delta u = f  u = u_0  u_t = v_0 endaligned","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Here f is the source function, u_0 and v_0 are initial conditions. For numerical simulation, the perfect matched layer boundary condition is used to truncate the computational domain. See Acoustic Wave Simulation for details. ","category":"page"},{"location":"backward_inversion/#Inverting-Velocity-Model","page":"Inversioin using Automatic Differentiation","title":"Inverting Velocity Model","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"In this model, c(x y) is unknown. Red dots represent n sources and triangles represent m receivers at locations mathbfx_i. We activate the sources one by one and collect the time serious signals u(t mathbfx_i) at the receivers for different source functions. Therefore, the observations are m mathbbR^n_ttimes n matrices, where n_t is the size of the time series. This inversion problem is called full waveform inversion, or FWI for short. ","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"The idea of FWI is updating c(x y) until the observations and the estimations–which are obtained from solving the wave equation–match. We do benchmarks on two classical models for c(xy): Marmousi model and Layer model. ","category":"page"},{"location":"backward_inversion/#Marmousi-model","page":"Inversioin using Automatic Differentiation","title":"Marmousi model","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Ground Truth Inversion\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"backward_inversion/#Layer-model","page":"Inversioin using Automatic Differentiation","title":"Layer model","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Ground Truth Inversion\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"To invert the acoustic wave velocity, we first create three containers for storing simulation results, source functions and receiver data","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"ap_sim = load_acoustic_model(\"models/layer-model-smooth.mat\"; inv_vp=true, IT_DISPLAY=0)\nsrc = load_acoustic_source(\"models/layer-model-smooth.mat\")\nrcv_sim = load_acoustic_receiver(\"models/layer-model-smooth.mat\")","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Then we load ground truth receiver data","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Rs = Array{Array{Float64,2}}(undef, length(src))\nfor i = 1:length(src)\n    Rs[i] = readdlm(joinpath(output_dir, \"layermodel-r$i.txt\"))\nend","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Since we want to run the model on multi-GPU, we instruct ADSeismic to compute the gradients and loss on GPUs and then assemble them on CPU","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"vp = get_collection()[1]\nlosses, gs = compute_loss_and_grads_GPU(ap_sim, src, rcv_sim, Rs, vp) # losses and gs are computed on GPUs\ng = sum(gs); loss = sum(losses) # g and loss are assembled on CPU","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Finally, the optimization can be triggered by LBFGS!, a built-in L-BFGS optimizer","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"sess = Session(); init(sess)\nLBFGS!(sess, loss, g, vp)","category":"page"},{"location":"backward_inversion/#Inverting-Source-Location-and-Time-Function","page":"Inversioin using Automatic Differentiation","title":"Inverting Source Location and Time Function","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"In this case, the location and amplitude function of the source (we assume there is one single source) is not known. The receivers are placed on the earth surface. We want to estimate the source term f based on the receiver information (which are m time series in mathbbR^n_t).","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Mathematically, f(t mathbfx) is a Delta function in mathbfx; to make the inversion problem continuous, we use ","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"f_theta(t mathbfx) = g(t) frac12pisigma^2exp(-fracmathbfx-theta^22sigma^2)","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"to approximate f(t mathbfx); here thetainmathbbR^2 and g(t) are unknown. ","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Source/Receiver Location Forward Simulation\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Source Time Function Inversion Source Location Inversion\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"backward_inversion/#Inverting-Rupture-Process","page":"Inversioin using Automatic Differentiation","title":"Inverting Rupture Process","text":"","category":"section"},{"location":"backward_inversion/#.-Invert-the-rupture-process-directly","page":"Inversioin using Automatic Differentiation","title":"1. Invert the rupture process directly","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Source/Receiver Location Forward Simulation\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Ground Truth Inversion\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"backward_inversion/#.-Inverte-the-slip-time-and-amplitude","page":"Inversioin using Automatic Differentiation","title":"2. Inverte the slip time and amplitude","text":"","category":"section"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"In this case, the functional form of the source function is known (see Gauss)","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"f(t) = frac2Api^2 a^2 expleft( -frac(t-t_0)^2pi^2 a^2 right)","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"where A is the amplitude, a is the parameter that controls width of the Gaussian, and t_0 is the shift of the parameter. ","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"Ground Truth Inversion\n(Image: ) (Image: )","category":"page"},{"location":"backward_inversion/","page":"Inversioin using Automatic Differentiation","title":"Inversioin using Automatic Differentiation","text":"(Image: )","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Data-Structure","page":"API Reference","title":"Data Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ADSeismic]\nPages   = [\"Struct.jl\"]","category":"page"},{"location":"api/#ADSeismic.AcousticPropagator","page":"API Reference","title":"ADSeismic.AcousticPropagator","text":"AcousticPropagator\n\nA structure holding all the information for acoustic simulation\n\n\n\n\n\n","category":"type"},{"location":"api/#ADSeismic.ElasticSource","page":"API Reference","title":"ADSeismic.ElasticSource","text":"mutable struct ElasticSource\n    srci::Union{Array{Int64, 1},PyObject}\n    srcj::Union{Array{Int64, 1},PyObject}\n    srctype::Union{Array{Int64, 1},PyObject}\n    srcv::Union{Array{Float64, 2},PyObject}\nend\n\nAdd source terms to different components according to srctype\n\n0: vx\n1: vy\n2: σxx\n3: σyy\n4: σxy\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation","page":"API Reference","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ADSeismic]\nPages   = [\"Core.jl\"]","category":"page"},{"location":"api/#ADSeismic.AcousticPropagatorSolver-Tuple{AcousticPropagatorParams,AcousticSource,Union{Array{Float64,2}, PyCall.PyObject}}","page":"API Reference","title":"ADSeismic.AcousticPropagatorSolver","text":"AcousticPropagatorSolver(param::AcousticPropagatorParams, src::AcousticSource, c::Union{PyObject, Array{Float64, 2}})\n\nArguments\n\n'param::AcousticPropagatorParams': model configuration parameters, such as NX, NT\n'src::AcousticSource': source locations\n'c::Union{PyObject, Array{Float64, 2}}': velocity model\n\nReturn\n\n'AcousticPropagator': forward calculation results, like displacement u\n\n\n\n\n\n","category":"method"},{"location":"api/#ADSeismic.SimulatedObservation!-Tuple{AcousticPropagator,AcousticReceiver}","page":"API Reference","title":"ADSeismic.SimulatedObservation!","text":"SimulatedObservation!(ap::AcousticPropagator, rcv::AcousticReceiver)\n\nExtract and save simulated displacement u into rcv::AcousticReceiver.\n\n\n\n\n\n","category":"method"},{"location":"api/#ADSeismic.pml_helper-Tuple{Float64,Float64,AcousticPropagatorParams}","page":"API Reference","title":"ADSeismic.pml_helper","text":"pml_helper(x::Float64, y::Float64, param::AcousticPropagatorParams)\n\nComputing the PML profile. \n\n\n\n\n\n","category":"method"},{"location":"api/#I/O","page":"API Reference","title":"I/O","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ADSeismic]\nPages   = [\"IO.jl\"]","category":"page"},{"location":"api/#ADSeismic.load_acoustic_model-Tuple{String}","page":"API Reference","title":"ADSeismic.load_acoustic_model","text":"loadacousticmodel(filename::String; inv_vp::Bool = false, kwargs...)\n\nLoad acoustic model from a MAT file.\n\nArguments\n\n'filename::String': MAT filename\n'inv_vp::Bool': inversion of velocity (default: false)\n\nReturn\n\nAcousticPropagatorSolver(src::AcousticSource)\n\n\n\n\n\n","category":"method"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ADSeismic]\nPages   = [\"Utils.jl\"]","category":"page"},{"location":"api/#ADSeismic.Ricker","page":"API Reference","title":"ADSeismic.Ricker","text":"Ricker(epp::Union{ElasticPropagatorParams, AcousticPropagatorParams}, \na::Union{PyObject, <:Real}, \nshift::Union{PyObject, <:Real}, \namp::Union{PyObject, <:Real}=1.0)\n\nReturns a Ricker wavelet (a tensor). \n\nepp: a ElasticPropagatorParams or an AcousticPropagatorParams\na: Width parameter\nshift: Center of the Ricker wavelet\namp: Amplitude of the Ricker wavelet\n\nf(x) = mathrmampA (1 - x^2a^2) exp(-x^22 a^2)\n\nwhere \n\nA = 2sqrt(3a)pi^14\n\n\n\n\n\n","category":"function"},{"location":"api/#ADSeismic.compute_loss_and_grads_GPU-Tuple{Function,Union{Array{AcousticSource,N} where N, Array{ElasticSource,N} where N},Union{Array{AcousticReceiver,N} where N, Array{ElasticReceiver,N} where N},Array{Array{Float64,2},1},Union{PyCall.PyObject, Array{PyCall.PyObject,N} where N}}","page":"API Reference","title":"ADSeismic.compute_loss_and_grads_GPU","text":"compute_loss_and_grads_GPU(model::Function, src::Union{Array{AcousticSource},Array{ElasticSource}},\nrcv_sim::Union{Array{AcousticReceiver}, Array{ElasticReceiver}}, Rs::Array{Array{Float64}}, vs::Union{PyObject, Array{PyObject}})\n\nComputes the loss and the gradients of the model on all available GPUs. \n\nmodel, src, rcv_sim: Model, Source and Receiver returned by load_acoustic_source, load_acoustic_model,    load_acoustic_receiver or load_elastic_source, load_elastic_model,    load_elastic_receiver\nRs: True receiver data\nvs: Variables to be optimized. It or its elements must have ref type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ADSeismic.sampling_compute_loss_and_grads_GPU_v2-NTuple{4,Any}","page":"API Reference","title":"ADSeismic.sampling_compute_loss_and_grads_GPU_v2","text":"models : nsrc * batch_size\nsrc : nsrc\nrcv_sim : nsrc * batch_size\nRs : nsrc * sample_size\n\n\n\n\n\n","category":"method"},{"location":"api/#ADSeismic.sampling_compute_loss_and_grads_GPU_v3-NTuple{4,Any}","page":"API Reference","title":"ADSeismic.sampling_compute_loss_and_grads_GPU_v3","text":"Mathcing statistics. \n\nmodels : nsrc * batch_size\nsrc : nsrc\nrcv_sim : nsrc * batch_size\nRs : nsrc * sample_size\n\n\n\n\n\n","category":"method"},{"location":"api/#ADSeismic.visualize_wavefield-Tuple{Array{Float64,3},Union{AcousticPropagatorParams, ElasticPropagatorParams, MPIAcousticPropagatorParams, MPIElasticPropagatorParams}}","page":"API Reference","title":"ADSeismic.visualize_wavefield","text":"visualize_wavefield(val::Array{Float64, 3}, \n    param::Union{ElasticPropagatorParams,AcousticPropagatorParams})\nvisualize_wavefield(val::Array{Array{Float64, 3}, 1}, \n    param::Union{MPIAcousticPropagatorParams, MPIElasticPropagatorParams})\n\nVisualizes the wavefield and returns the handle of the animation. You can save the animation to gif via \n\np = visualize_wavefield(...)\nsaveanim(p, \"myfigure.gif\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [ADSeismic]\nPages   = [\"Optim.jl\"]","category":"page"},{"location":"api/#ADSeismic.LBFGS!","page":"API Reference","title":"ADSeismic.LBFGS!","text":"LBFGS!(sess::PyObject, loss::PyObject, max_iter::Int64=15000; \nvars::Array{PyObject}=PyObject[], callback::Union{Function, Nothing}=nothing, kwargs...)\n\nBFGS! is a simplified interface for BFGS optimizer. See also ScipyOptimizerInterface. callback is a callback function with signature \n\ncallback(vs::Array, iter::Int64, loss::Float64)\n\nvars is an array consisting of tensors and its values will be the input to vs.\n\nExample 1\n\na = Variable(1.0)\nloss = (a - 10.0)^2\nsess = Session(); init(sess)\nBFGS!(sess, loss)\n\nExample 2\n\nθ1 = Variable(1.0)\nθ2 = Variable(1.0)\nloss = (θ1-1)^2 + (θ2-2)^2\ncb = (vs, iter, loss)->begin \n    printstyled(\"[#iter $iter] θ1=$(vs[1]), θ2=$(vs[2]), loss=$loss\\n\", color=:green)\nend\nsess = Session(); init(sess)\ncb(run(sess, [θ1, θ2]), 0, run(sess, loss))\nBFGS!(sess, loss, 100; vars=[θ1, θ2], callback=cb)\n\nExample 3\n\nUse bounds to specify upper and lower bound of a variable. \n\nx = Variable(2.0)    \nloss = x^2\nsess = Session(); init(sess)\nBFGS!(sess, loss, bounds=Dict(x=>[1.0,3.0]))\n\n\n\n\n\n","category":"function"},{"location":"api/#ADSeismic.LBFGS!-2","page":"API Reference","title":"ADSeismic.LBFGS!","text":"LBFGS!(value_and_gradients_function::Function, initial_position::Union{PyObject, Array{Float64}}, max_iter::Int64=50, args...;kwargs...)\n\nApplies the BFGS optimizer to value_and_gradients_function\n\n\n\n\n\n","category":"function"},{"location":"api/#ADSeismic.LBFGS!-Union{Tuple{T}, Tuple{PyCall.PyObject,PyCall.PyObject,Union{Nothing, PyCall.PyObject, Array{T,N} where N},Union{PyCall.PyObject, Array{PyCall.PyObject,N} where N}}} where T<:Union{Nothing, PyCall.PyObject}","page":"API Reference","title":"ADSeismic.LBFGS!","text":"LBFGS!(sess::PyObject, loss::PyObject, grads::Union{Array{T},Nothing,PyObject}, \nvars::Union{Array{PyObject},PyObject}; kwargs...) where T<:Union{Nothing, PyObject}\n\nRunning BFGS algorithm min_textttvars textttloss(textttvars) The gradients grads must be provided. Typically, grads[i] = gradients(loss, vars[i]).  grads[i] can exist on different devices (GPU or CPU). \n\nExample 1\n\nimport Optim # required\na = Variable(0.0)\nloss = (a-1)^2\ng = gradients(loss, a)\nsess = Session(); init(sess)\nBFGS!(sess, loss, g, a)\n\nExample 2\n\nimport Optim # required\na = Variable(0.0)\nloss = (a^2+a-1)^2\ng = gradients(loss, a)\nsess = Session(); init(sess)\ncb = (vs, iter, loss)->begin \n    printstyled(\"[#iter $iter] a = $vs, loss=$loss\\n\", color=:green)\nend\nBFGS!(sess, loss, g, a; callback = cb)\n\n\n\n\n\n","category":"method"},{"location":"contents/#Script-Reference","page":"Script Reference","title":"Script Reference","text":"","category":"section"},{"location":"contents/","page":"Script Reference","title":"Script Reference","text":"Script Description\nBenchmarkAcoustic.jl Benchmarking CPU/GPU Performance for Acoustic Simulation\nBenchmarkElastic.jl Benchmarking CPU/GPU Performance for Elastic Simulation\nAcousticMultiGPU.jl Acoustic wave simulation using multi-GPUs\nAcousticFWIMultiGPU.jl Acoustic wave full waveform inversion using multi-GPUs","category":"page"},{"location":"NNFWI/#NNFWI","page":"NNFWI","title":"NNFWI","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"Integrating Deep Neural Networks with Full-waveform Inversion: Reparametrization, Regularization, and Uncertainty Quantification","category":"page"},{"location":"NNFWI/#Architecture","page":"NNFWI","title":"Architecture","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"(Image: )","category":"page"},{"location":"NNFWI/#Forward-Simulation","page":"NNFWI","title":"Forward Simulation","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"Marmousi model Inital 1D model\n(Image: ) (Image: )","category":"page"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"BP2004 model Inital 1D model\n(Image: ) (Image: )","category":"page"},{"location":"NNFWI/#Inversion-based-on-Automatic-Differentiation","page":"NNFWI","title":"Inversion based on Automatic Differentiation","text":"","category":"section"},{"location":"NNFWI/#Loss-function","page":"NNFWI","title":"Loss function","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"Noise level Marmousi model BP2004 model\nsigma=0 (Image: ) (Image: )\nsigma=05 (Image: ) (Image: )","category":"page"},{"location":"NNFWI/#Marmousi-model","page":"NNFWI","title":"Marmousi model","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"Noise level Traditional  FWI NNFWI\nsigma=0 (Image: ) (Image: )\nsigma=05 (Image: ) (Image: )\nsigma=1 (Image: ) (Image: )","category":"page"},{"location":"NNFWI/#BP2004-model","page":"NNFWI","title":"BP2004 model","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"Noise level Traditional  FWI NNFWI\nsigma=0 (Image: ) (Image: )\nsigma=05 (Image: ) (Image: )\nsigma=1 (Image: ) (Image: )","category":"page"},{"location":"NNFWI/#Uncertainty-Quantification-using-Dropout","page":"NNFWI","title":"Uncertainty Quantification using Dropout","text":"","category":"section"},{"location":"NNFWI/","page":"NNFWI","title":"NNFWI","text":"Inverted V_p std(V_p) std(V_p)/V_p cdot 100%\n(Image: ) (Image: ) (Image: )\n(Image: ) (Image: ) (Image: )","category":"page"},{"location":"ad/#Inverse-Modeling","page":"Inverse Modeling","title":"Inverse Modeling","text":"","category":"section"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Inverse modeling (IM) identifies a certain set of parameters or functions with which the outputs of the forward analysis matches the desired result or measurement. IM can usually be solved by formulating it as an optimization problem. But the major difference is that IM aims at getting information not accessible to forward analysis, instead of obtaining an optimal value of a fixed objective function and set of constraints. In IM, the objective function and constraints can be adjusted, and prior information of the unknown parameters or functions can be imposed in the form of regularizers, to better reflect the physical laws. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"For example, given an image xinmathbbR^1024times 1024, the forward analysis is given by y = F(x) = sum_ij x_ij, i.e., the summation of all pixel values. One possible IM problem requires you to estimate x given the measurement y. It can be formulated an optimization problem min_x (F(x)-y)^2, which is underdetermined. However, if we have the prior that the image is a pure color image, then the inverse problem is well-defined and has a unique solution. There are many ways to impose this prior as contraints to the optimization problem, but the IM problem itself may not be described as an optimization problem. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"(Image: )","category":"page"},{"location":"ad/#Automatic-Differentiation","page":"Inverse Modeling","title":"Automatic Differentiation","text":"","category":"section"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"One powerful tool in inverse modeling is automatic differentiation (AD). Automatic differentiation is a general way to compute gradients based on the chain rule. By tracing the forward-pass computation, the gradient at the final step can propagate back to every operator and every parameter in a computational graph. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"As an example, a neural network model mainly consists of a sequence of linear transforms and non-linear activation functions. The goal of the training process is to minimize the error between its prediction and the label of ground truth. Automatic differentiation is used to calculate the gradients of every variable by back-propagating the gradients from the loss function to the trainable parameters, i.e., the weights and biases of neural networks. The gradients are then used in a gradient-based optimizer such as gradient descent methods to update the parameters. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"For another example, the physical forward simulation is similar to the neural network model in that they are both sequences of linear/non-linear transforms. One popular method in physical simulation, the FDTD (Finite-Difference Time-Domain) method, applies a finite difference operator to a consecutive time steps to solve time-dependent partial differential equations (PDEs). In seismic problems, we can specify parameters such as earthquake source functions and earth media properties to simulate the received seismic signals. In seismic inversion problems, those parameters are unknown and we can invert the underlining source characteristic and media property by minimizing the difference between the simulated seismic signals and the observed ones. In the framework of automatic differentiation, the gradients of the difference can be computed automatically and thus used in a gradient-based optimizer. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"(Image: )","category":"page"},{"location":"ad/#AD-Implementation-in-ADCME","page":"Inverse Modeling","title":"AD Implementation in ADCME","text":"","category":"section"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"ADCME uses TensorFlow as the backend for automatic differentiation. However, one major difference of ADCME compared with TensorFlow is that it provides a friendly syntax for scientific computing (essentially the same syntax as native Julia). This substantially reduces development time. In addition, ADCME augments TensorFlow libraries by adding missing features that are useful for scientific computing, such as sparse matrix solve, sparse least square, sparse assembling, etc. Additionally, Julia interfaces make it possible for directly implementing efficient numerical computation parts of the simulation (requires no automatic differentiation), for interacting with other languages (MATLAB, C/C++, R, etc.) and for built-in Julia parallelism. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"As an example, we show how a convoluted acoustic wave equation simulation with PML boundary condition can be translated to Julia codes with AD feature very neatly. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"(Image: )","category":"page"},{"location":"ad/#Forward-Operator-Types","page":"Inverse Modeling","title":"Forward Operator Types","text":"","category":"section"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"All numerical simulations can be decomposed into operators that are chained together. These operators range from a simple arithmetic operation such as addition or multiplication, to more sophisticated computation such as solving a linear system. Automatic differentiation relies on the differentiation of those operators and integrates them with chain rules. Therefore, it is very important for us to study the basic types of existing operators. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"(Image: Operators)","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"In this tutorial, a operator is defined as a numerical procedure that accepts a parameter called input, x, and turns out a parameter called ouput, y=f(x). For reverse mode automatic differentiation, besides evaluating f(x), we need also to compute fracpartial Jpartial x given fracpartial Jpartial y where J is a functional of y. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Note  the operator y=f(x) may be implicit in the sense that f is not given directly. In general, we can write the relationship between x and y as F(xy)=0. The operator is well-defined if for given x, there exists one and only one y such that F(xy)=0. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"For automatic differentiation, besides the well-definedness of F, we also require that we can compute fracpartial Jpartial x given fracpartial Jpartial y. It is easy to see that","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"fracpartial Jpartial x = -fracpartial Jpartial yF_y^-1F_x","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Therefore, we call an operator F is well-posed if F_y^-1 exists. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"All operators can be classified into four types based on the linearity and explicitness.","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Linear and explicit","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"This type of operators has the form ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"y = Ax","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"where A is a matrix. In this case, ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"F(xy) = Ax-y","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"and therefore ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"fracpartial Jpartial x = fracpartial Jpartial yA","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"In Tensorflow, such an operator can be implemented as (assuming A is )","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"import tensorflow as tf\n@tf.custom_gradient\ndef F(x):\n​      u = tf.linalg.matvec(A, x)\n​      def grad(dy):\n​          return tf.linalg.matvec(tf.transpose(A), dy)\n​      return u, grad","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Nonlinear and explicit","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"In this case, we have ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"y = F(x)","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"where F is explicitly given. We have","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"F(xy) = F(x)-yRightarrow fracpartial Jpartial x = fracpartial Jpartial y F_x(x)","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"One challenge here is we need to implement the matrix vector production fracpartial Jpartial y F_x(x) for grad. ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Linear and implicit","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"In this case ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Ay = x","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"We have F(xy) = x-Ay and ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"fracpartial Jpartial x = fracpartial Jpartial yA^-1","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"Nonlinear and implicit","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"In this case F(xy)=0 and the corresponding gradient is ","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"fracpartial Jpartial x = -fracpartial Jpartial yF_y^-1F_x","category":"page"},{"location":"ad/","page":"Inverse Modeling","title":"Inverse Modeling","text":"This case is the most challenging of the four but widely seen in scientific computing code. In many numerical simulation code, F_y is usually sparse and therefore it is rewarding to exploit the sparse structure for computation acceleration in practice.","category":"page"},{"location":"forward_simulation/#Forward-Simulation","page":"Forward Simulation","title":"Forward Simulation","text":"","category":"section"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"In this section, we describe forward simulation for acoustic and elastic equations. ","category":"page"},{"location":"forward_simulation/#Acoustic-Wave-Simulation","page":"Forward Simulation","title":"Acoustic Wave Simulation","text":"","category":"section"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"We consider a time dependent wave field u propagating through an unbounded domain mathbbR^2. In Omega, the wave field u satisfies ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"beginaligned u_tt - c^2Delta u = f  u = u_0  u_t = v_0 endaligned","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"Here f is the source function, u_0 and v_0 are initial conditions. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"We truncate the computational domain to a bounded 2D domain Omegain mathbbR^2. To prevent the wave field to reflect from the boundaries, perfect matched layer (PML) are usually used to absorb the waves. Mathematically, the governing equation can be described by a modified partial differential equation (PDE) system with auxilliary variables phi","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"beginalignedu_tt + (xi _1 + xi _2)u_t + xi _1xi _2u = c^2Delta u + nabla  cdot phi    phi _t = Gamma _1phi  + c^2Gamma _2nabla uendaligned","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"and Gamma_1 and Gamma_2 are defined by","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"Gamma _1 = left matrix  - xi _1    cr       - xi _2  cr    rightquadGamma _2 = left matrixxi _2 - xi _1    cr      xi _1 - xi _2  cr   right","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The terms xi_i(x)geq 0, i=12 are the damping profiles and only depend on x_i (x=(x_1x_2)). In our example, we use","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"xi _i(x) = left matrix0quad xnot  in tilde Omega   cr    bar xi _ileft( d(xtilde Omega ) over L_i - sin left( 2pi d(xtilde Omega ) over L_i right) over 2pi  right)quad x intilde Omega   cr    right","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"Here L_i is the PML width in x and y direction and tilde Omega_i is the domain excluding the PML layer in the x (i=1) or y (i=2) direction. d(x tildeOmega_i) is the distance between x and tildeOmega_i. See the following figure for illustration. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"(Image: )","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The profiling coefficient barxi_i is given by the relative reflection R (we always use R=0001), the (estimated) velocity of acoustic waves c and the PML width L_i","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"barxi_i = fraccL_ilogleft(frac1Rright)","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"In what follows, we assume the velocity is given by the elastic Marmousi model. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"(Image: )","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The following code snippet shows how we can run the forward simulation with the 13-th source function. For how to generate the dataset marmousi2_model_big_true.mat, we refer you to the notebooks. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"using ADSeismic\nusing ADCME\nusing PyPlot\n\nmatplotlib.use(\"agg\")\nmodel = load_acoustic_model(\"models/marmousi2_model_big_true.mat\", IT_DISPLAY=50)\nsrc = load_acoustic_source(\"models/marmousi2_model_big_true.mat\")\nrcv = load_acoustic_receiver(\"models/marmousi2_model_big_true.mat\") # assume there is only one receiver\n\n@assert length(src)==length(rcv)\nfor i = 1:length(src)\n\tSimulatedObservation!(model(src[i]), rcv[i])\nend\n\nsess = Session(); init(sess)\nu = run(sess, model(src[13]).u)\nvisualize_file(u, model.param, dirs=\"$(@__DIR__)/../docs/src/asset/Acoustic\")","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The following animation shows the simulation result. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"(Image: )","category":"page"},{"location":"forward_simulation/#Elastic-Wave-Simulation","page":"Forward Simulation","title":"Elastic Wave Simulation","text":"","category":"section"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The governing equation for the elastic wave propagation is","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"beginalignedrho fracpartial v_zpartial t = fracpartial sigma_zzpartial z + fracpartial sigma_xzpartial x  rho fracpartial v_xpartial t = fracpartial sigma_xxpartial x + fracpartial sigma_xzpartial z    fracpartial sigma_zzpartial t = (lambda + 2mu)fracpartial v_zpartial z + lambdafracpartial v_xpartial x    fracpartial sigma_xxpartial t = (lambda + 2mu)fracpartial v_xpartial x + lambdafracpartial v_zpartial z    fracpartial sigma_xzpartial t = mu fracpartial v_zpartial x + lambdafracpartial v_xpartial zendaligned","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"Here ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"Variable Description\nv_x v_z Velocity of the wave field in the x and z direction\nsigma_xx sigma_zz sigma_xz Stress tensor\nrho Density of the media\nlambda Lamé's first parameter\nmu Shear modulus","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The following animation shows the simulation result for v_z. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"(Image: )","category":"page"},{"location":"forward_simulation/#Benchmark-of-Acoustic-Wave-Simulation-on-CPU-and-GPU","page":"Forward Simulation","title":"Benchmark of Acoustic Wave Simulation on CPU and GPU","text":"","category":"section"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"We benchmark the simulation on CPU and GPU. The configuration for GPU and CPU are ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"CPU GPU\nIntel(R) Xeon(R) Gold 5118 CPU @ 2.30GHz NVIDIA Tesla V100-PCIE-32GB","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The benchmark script can be found in BenchmarkAcoustic.jl and BenchmarkElastic.jl.  ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The following shows the comparison of the simulation time for CPU and GPU. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"Acoustic Simulation Elastic Simulation\n(Image: ) (Image: )","category":"page"},{"location":"forward_simulation/#Multi-GPUs","page":"Forward Simulation","title":"Multi-GPUs","text":"","category":"section"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"With only a few modification to the original simulation codes, the model can also be run on multi-GPUs (see AcousticMultiGPU.jl for the full script). In this example, we compute the gradients of the loss function (the discrepancy between the observed seismic data and the simulated seismic data) with respect to the acoustic velocity. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"In the following code snippets, we explicitly place different source functions to different GPUs. This can be done with the  @pywith tf.device(\"/gpu:0\") syntax, and the enclosed codes are executed on 0-th GPU.  ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"using ADSeismic\nusing ADCME\nusing PyPlot\nusing PyCall\nusing DelimitedFiles\nreset_default_graph()\n\nsrc = load_acoustic_source(\"models/marmousi2_model_initial.mat\")\nep_sim = load_acoustic_model(\"models/marmousi2_model_initial.mat\"; inv_vp=true, IT_DISPLAY=0)\nrcv_sim = load_acoustic_receiver(\"models/marmousi2_model_initial.mat\")\n\n\nRs = Array{Array{Float64,2}}(undef, length(src))\nfor i = 1:length(src)\n    Rs[i] = readdlm(\"models/AcousticData/Acoustic-R$i.txt\")\nend\n\n\nfunction run_on_gpu_device(batch_id)\n    local loss, g\n    @pywith tf.device(\"/gpu:$(batch_id-1)\") begin\n        [SimulatedObservation!(ep_sim(src[i]), rcv_sim[i]) for i = batch_id]\n        loss = sum([sum((rcv_sim[i].rcvv-Rs[i])^2) for i = batch_id]) \n        g = gradients(loss, get_collection()[1])\n    end\n    return loss, g\nend\n\nlosses = Array{PyObject}(undef, 8)\ngs = Array{PyObject}(undef, 8)\nfor i = 1:8\n    losses[i], gs[i] = run_on_gpu_device(i)\nend\ng = sum(gs)\nsess = Session(); init(sess)\nrun(sess, g)","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"The following plot shows the dataflow of the above computation. ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"(Image: )","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"We take the snapshot of nvidia-smi and it shows the memory and computation utilization of GPUs on a DGX server with 8 Tesla V100s ","category":"page"},{"location":"forward_simulation/","page":"Forward Simulation","title":"Forward Simulation","text":"(Image: )","category":"page"},{"location":"#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"An Open Source High Performance Package for General Seismic Inversion Problems","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"ADSeismic is suitable for general inversion problems in seismic imaging. The packages implements the forward simulation of acoustic and elastic wave fields and allows inversion of physical properties such as media densities, Lamé parameters, shear modulus, etc. by means of automatic differentiation. For example, the following problems fall into the scope of this framework","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Full waveform inversion (FWI)\nRupture inversion\nSource-time inversion","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The package provides a unified interface for both acoustic and elastic wave simulation. Users only need to specify the geometries and known parameters of the physical simulation. Gradients (traditionally derived by adjoint methods) are computed automatically. Some notable features of this package are","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Battery included: unified approach to various seismic inversion problems such as full waveform inversion (FWI), rupture inversion and source-time inversion.\nHigh performance: computational graph optimization and parallel computing. \n(Multi-)GPU support: support for GPU acceleration as well as multi-GPU (in theory TPUs are also supported).\nEasy-to-use: no adjoint state method codes required for building your own inversion models; automatic differentiation is the workhorce.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"ADSeismic is built on ADCME.jl, an automatic differentiation library for computational mathematics and engineering. The former is fully compatible with ADCME.jl, which indicates that this package (ADSeismic.jl) can serve as a acoustic/elastic simulation solver in a system inverse modeling problem. ","category":"page"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"ADCME is a dependency for using this package. Install ADCME with","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"using Pkg; Pkg.add(\"ADCME\")","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Then install the lastest ADSeismic.jl by","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"using Pkg; Pkg.add(\"https://github.com/kailaix/ADSeismic.jl#master\")","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"or the stable version by ","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"using Pkg; Pkg.add(\"ADSeismic\")","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"If you want to use GPU for ADSeismic, you need to install the GPU-capable ADCME. See instructions [here](https://kailaix.github.io/ADCME.jl/latest/tu_customop/#Install-GPU-enabled-TensorFlow-(Linux-and-Windows).","category":"page"},{"location":"#Simple-Example:-Acoustic-Wave-Equation","page":"Getting Started","title":"Simple Example: Acoustic Wave Equation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"We consider the acoustic wave equation ","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"fracpartial^2 u partial t^2 = nabla cdot (c^2 nabla u) + f","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"where u is the displacement, f is the source term, and c is the spatially varying acoustic velocity. In numerical simulations, we apply the perfect matched layer (PML) boundary conditions so that the outgoing waves are damped near the boundary. This enables us to emulate an infinite space using a finite computational domain. A description of the numerical scheme could be found in this paper. [pml]","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"[pml]: Grote, Marcus J., and Imbo Sim. \"Efficient PML for the wave equation.\" arXiv preprint arXiv:1001.0319 (2010).","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"In the forward simulation, we consider a layer model as the ground truth for c, which consists of three layers with different values: (Image: )","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"We consider a delta source function f(mathbfx t) = delta(mathbfx-mathbfx_0)g(t), where g(t) is a Ricker wavelet. ","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Using this source function (left plot), we are able to generate the wavefield (right plot)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Source Function Wavefield\n(Image: ) (Image: )","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The code for forward simulation is as follows:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"using ADCME\nusing ADSeismic\nusing PyPlot\nusing DelimitedFiles\nusing JLD2 \n\nscale = 201\n \nparam = AcousticPropagatorParams(NX=scale, NY=scale, \n    NSTEP=1000, DELTAT=1e-4,  DELTAX=1.0, DELTAY=1.0,\n    PropagatorKernel = 0, Rcoef = 1e-8)\n\nrc = Ricker(param, 30.0, 200.0, 1e6)\nsrci = [div(param.NX,2)]\nsrcj = [div(param.NY,5)]\nsrcv = reshape(rc, :, 1)\nsrc = AcousticSource(srci, srcj, srcv)\n\nlayers = ones(param.NX+2, param.NY+2)\nn_piece = div(param.NX + 1, 3) + 1\nfor k = 1:3\n    i_interval = (k-1)*n_piece+1:min(k*n_piece, param.NX+2)\n    layers[:, i_interval] .= 0.5 + (k-1)*0.25\nend\n\nC = placeholder(3300*layers)\nmodel = AcousticPropagatorSolver(param, src, C)\n\nsess = Session(); init(sess)\nu = run(sess, model.u)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"In the inverse problem, we assume we can observe the wavefield u(x 40 t) for all x and t. The unknown is the velocity model c. We can find the value of c by solving the PDE-constrained optimization problem ","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"beginaligned min_c  sum_ (u_h(x_i 40 t_j) - u(x_i 40 t_j))^2  textst  F_h(u_h c) = 0endaligned","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here F_h(u_h c)=0 is the numerical discretization of the wave equation and u_h is the numerical solution for all time steps. The following plot shows the signal we received:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"We can apply automatic differentiation with the following code to calculate the gradients of the loss function with respect to c","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"using ADCME\nusing ADSeismic\nusing PyPlot\nusing DelimitedFiles\nusing JLD2 \n\nscale = 201\n \nparam = AcousticPropagatorParams(NX=scale, NY=scale, \n    NSTEP=1000, DELTAT=1e-4,  DELTAX=1.0, DELTAY=1.0,\n    PropagatorKernel = 0, Rcoef = 1e-8)\n\nrc = Ricker(param, 30.0, 200.0, 1e6)\nsrci = [div(param.NX,2)]\nsrcj = [div(param.NY,5)]\nsrcv = reshape(rc, :, 1)\nsrc = AcousticSource(srci, srcj, srcv)\n\n\nC = Variable(3300*ones(param.NX+2, param.NY+2))\nmodel = AcousticPropagatorSolver(param, src, C)\n@load \"data.jld2\" u \n\nU = model.u\nloss = sum((u[:, :, 40] - U[:,:,40])^2)\ng = gradients(loss, C)\n\nsess = Session(); init(sess)\nG = run(sess, g)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The gradient at the first step is shown below:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The codes can be found here.","category":"page"}]
}
